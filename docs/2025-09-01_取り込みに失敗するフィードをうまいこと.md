# フィード正規化フィルタシステム設計・実装書

## 1. 背景と問題提起

### 1.1 現状の課題
GitHub Issue #362にて、複数のフィードが登録できない問題が報告されている。現在のChannelモデルは、厳格なバリデーションにより「正しい」フィードのみを受け入れる設計となっているが、実際のWebには様々な「不完全な」フィードが存在する。

### 1.2 報告されている問題のあるフィード
- https://www.ryuzee.com/feed
- https://www.ele-king.net/
- https://www.festival-life.com
- https://www.nan1.casa/index.xml
- https://tbsmcd.net/index.xml
- https://cast.kwappa.net/feed.xml
- https://feeds.megaphone.fm/guildtalk

## 2. 調査結果

### 2.1 発見された問題パターン

#### パターン1: 相対URL問題
**事例**: tbsmcd.net/index.xml
```xml
<link>/</link>  <!-- 相対パスになっている -->
<item>
  <link>/post/playwright-mcp-with-selfmade-mcp/</link>
</item>
```
**影響**:
- `UrlHttpValidator`がバリデーションエラーを起こす
- OpenGraph取得時にTCP接続エラー

#### パターン2: Atom名前空間の誤り
**事例**: ele-king.net/atom.xml
```xml
<feed xmlns="https://www.w3.org/2005/Atom">  <!-- httpsではなくhttpが正しい -->
```
**影響**: Feedjira::NoParserAvailableエラー

#### パターン3: 空のフィールド
**事例**: festival-life.com/feed
```xml
<title></title>  <!-- タイトルが空 -->
```
**影響**: Channelモデルのバリデーションエラー

#### パターン4: URLフィールドの欠落
**事例**: feeds.megaphone.fm/guildtalk
- feed.urlがnilになる
- エントリーのURLも取得できない

## 3. 実装されたソリューション：フィード正規化フィルタシステム

### 3.1 基本コンセプト
「不完全なフィードを拒否する」のではなく「修正可能な問題は自動修正し、その履歴を記録する」アプローチを採用。

### 3.2 アーキテクチャ

```
[外部フィード URL]
        ↓
[Httpc.get] - HTTPリクエストでXML取得
        ↓
[FeedNormalizer] ← フィルタパイプライン管理
    │
    ├─ Pre-parseフィルタ（XML文字列レベル）
    │   └─ AtomNamespaceFixer
    │
    ├─ [Feedjira.parse] - XMLをパース
    │
    └─ Post-parseフィルタ（オブジェクトレベル）
        └─ RelativeUrlResolver
        ↓
[正規化されたフィードオブジェクト]
        ↓
[Channel.save_from / Channel.add]
        ↓
[保存（フィルタ履歴も記録）]
```

### 3.3 2層フィルタシステム

#### Pre-parseフィルタ
- **対象**: 生のXML文字列
- **目的**: XMLパーサが処理できるように修正
- **実装済み**: `AtomNamespaceFixer`

#### Post-parseフィルタ
- **対象**: パース済みのフィードオブジェクト
- **目的**: データの正規化と補完
- **実装済み**: `RelativeUrlResolver`

## 4. 実装されたクラス構造

### 4.1 FeedNormalizerクラス

```ruby
class FeedNormalizer
  PRE_PARSE_FILTERS = [
    FeedFilters::PreParse::AtomNamespaceFixer
  ].freeze

  POST_PARSE_FILTERS = [
    FeedFilters::PostParse::RelativeUrlResolver
  ].freeze

  def self.normalize_and_parse(raw_xml, feed_url)
    new(raw_xml, feed_url).normalize_and_parse
  end

  def normalize_and_parse
    # Step 1: Pre-parseフィルタを適用
    normalized_xml = apply_pre_parse_filters(@raw_xml)

    # Step 2: Feedjiraでパース
    feed = Feedjira.parse(normalized_xml)

    # Step 3: Post-parseフィルタを適用
    normalized_feed = apply_post_parse_filters(feed)

    {
      feed: normalized_feed,
      applied_filters: @applied_filters,
      filter_details: @filter_details
    }
  end
end
```

### 4.2 基底クラス

#### Pre-parseフィルタ基底クラス
```ruby
module FeedFilters
  module PreParse
    class Base
      attr_reader :applied, :details

      def applicable?(xml_content, metadata = {})
        raise NotImplementedError
      end

      def apply(xml_content, metadata = {})
        raise NotImplementedError
      end

      protected

      def mark_as_applied!(details = {})
        @applied = true
        @details = details
      end
    end
  end
end
```

#### Post-parseフィルタ基底クラス
```ruby
module FeedFilters
  module PostParse
    class Base
      attr_reader :applied, :details

      def applicable?(feed, metadata = {})
        raise NotImplementedError
      end

      def apply(feed, metadata = {})
        raise NotImplementedError
      end

      protected

      def mark_as_applied!(details = {})
        @applied = true
        @details = details
      end
    end
  end
end
```

### 4.3 実装済みフィルタ

#### AtomNamespaceFixer（Pre-parse）
**責務**: Atom XMLの名前空間URLをhttpsからhttpに修正
**対象**: ele-king.net等

```ruby
module FeedFilters
  module PreParse
    class AtomNamespaceFixer < Base
      def applicable?(xml_content, metadata = {})
        xml_content.include?('xmlns="https://www.w3.org/2005/Atom"') ||
          xml_content.include?("xmlns='https://www.w3.org/2005/Atom'")
      end

      def apply(xml_content, metadata = {})
        modified_xml = xml_content.dup

        # httpsをhttpに修正
        modified_xml.gsub!('xmlns="https://www.w3.org/2005/Atom"',
                          'xmlns="http://www.w3.org/2005/Atom"')

        mark_as_applied!(
          fixed: "Atom namespace URL protocol",
          original_namespace: 'xmlns="https://www.w3.org/2005/Atom"',
          corrected_namespace: 'xmlns="http://www.w3.org/2005/Atom"'
        )

        modified_xml
      end
    end
  end
end
```

#### RelativeUrlResolver（Post-parse）
**責務**: 相対URLを絶対URLに変換
**対象**: tbsmcd.net等

```ruby
module FeedFilters
  module PostParse
    class RelativeUrlResolver < Base
      def applicable?(feed, metadata = {})
        has_relative_url?(feed.url) ||
          feed.entries.any? { |entry| has_relative_url?(entry.url) }
      end

      def apply(feed, metadata = {})
        feed_url = metadata[:feed_url]
        base_url = extract_base_url(feed_url)
        converted_urls = []

        # フィードとエントリーのURLを修正
        if has_relative_url?(feed.url)
          resolved_url = resolve_url(feed.url, base_url)
          feed.url = resolved_url
          converted_urls << { from: feed.url, to: resolved_url, target: "feed" }
        end

        feed.entries.each do |entry|
          if has_relative_url?(entry.url)
            resolved_url = resolve_url(entry.url, base_url)
            entry.url = resolved_url
            converted_urls << { from: entry.url, to: resolved_url, target: "entry" }
          end
        end

        mark_as_applied!(
          base_url: base_url,
          converted_count: converted_urls.size,
          sample_urls: converted_urls.first(5)
        )

        feed
      end

      private

      def has_relative_url?(url)
        return false if url.blank?
        url.start_with?("/") || !url.start_with?("http://", "https://")
      end

      def resolve_url(url, base_url)
        return url if url.start_with?("http://", "https://")

        if url.start_with?("/")
          "#{base_url}#{url}"
        else
          URI.join(base_url, url).to_s
        end
      end
    end
  end
end
```

## 5. データベース設計

### 5.1 channelsテーブルへの追加カラム

```ruby
class AddFilterInfoToChannels < ActiveRecord::Migration[7.0]
  def change
    add_column :channels, :applied_filters, :json, default: []
    add_column :channels, :filter_details, :json, default: {}
  end
end
```

### 5.2 データ構造例

```json
{
  "applied_filters": [
    "AtomNamespaceFixer",
    "RelativeUrlResolver"
  ],
  "filter_details": {
    "AtomNamespaceFixer": {
      "fixed": "Atom namespace URL protocol",
      "original_namespace": "xmlns=\"https://www.w3.org/2005/Atom\"",
      "corrected_namespace": "xmlns=\"http://www.w3.org/2005/Atom\""
    },
    "RelativeUrlResolver": {
      "base_url": "https://tbsmcd.net",
      "converted_count": 15,
      "sample_urls": [
        { "from": "/", "to": "https://tbsmcd.net/", "target": "feed" },
        { "from": "/post/...", "to": "https://tbsmcd.net/post/...", "target": "entry" }
      ]
    }
  }
}
```

## 6. UI実装（現状）

### 6.1 Channelページでの表示

```erb
<% if @channel.applied_filters.present? && @channel.applied_filters.any? %>
  <div class="my-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
    <div class="flex items-center gap-2">
      <span class="material-symbols-outlined text-blue-600" style="font-size: 18px;">build</span>
      <div class="flex-1">
        <span class="text-sm text-blue-800">
          Applied Filters:
          <% @channel.applied_filters.each_with_index do |filter_name, index| %>
            <span class="font-medium"><%= filter_name %></span><%= index < @channel.applied_filters.length - 1 ? ", " : "" %>
          <% end %>
        </span>
      </div>
    </div>
  </div>
<% end %>
```

## 7. Channelモデルの統合

### 7.1 フィード追加時の自動適用

```ruby
class Channel < ApplicationRecord
  def self.add(url)
    normalization_result = fetch_and_normalize_feed(url)
    feed = normalization_result[:feed]
    save_from(url, normalization_result)
  end

  def self.fetch_and_normalize_feed(feed_url)
    raw_xml = Httpc.get(feed_url)
    FeedNormalizer.normalize_and_parse(raw_xml, feed_url)
  end

  def self.save_from(feed_url, normalization_result = nil)
    normalization_result ||= fetch_and_normalize_feed(feed_url)

    parameters = build_from(feed, feed_url)
    parameters.merge!(
      applied_filters: normalization_result[:applied_filters],
      filter_details: normalization_result[:filter_details]
    )

    channel = Channel.find_or_initialize_by(feed_url: feed_url)
    channel.update(parameters)
    channel
  end
end
```

### 7.2 アイテム取得時の自動適用

```ruby
def fetch_and_save_items(mode = :only_non_existing)
  # 毎回FeedNormalizerを通して正規化
  normalization_result = self.class.fetch_and_normalize_feed(feed_url)
  feed = normalization_result[:feed]

  # エントリーを処理...
end
```

## 8. テスト実装

### 8.1 FeedNormalizerTest

```ruby
class FeedNormalizerTest < ActiveSupport::TestCase
  test "applies pre-parse filters to fix Atom namespace" do
    xml_with_https = <<~XML
      <?xml version="1.0" encoding="UTF-8"?>
      <feed xmlns="https://www.w3.org/2005/Atom">
        <title>Test Feed</title>
      </feed>
    XML

    result = FeedNormalizer.normalize_and_parse(xml_with_https, "http://example.com/feed.xml")

    assert_not_nil result[:feed]
    assert_includes result[:applied_filters], "AtomNamespaceFixer"
  end

  test "applies post-parse filters to resolve relative URLs" do
    xml_with_relative_urls = <<~XML
      <?xml version="1.0" encoding="UTF-8"?>
      <rss version="2.0">
        <channel>
          <link>/</link>
          <item>
            <link>/post/1</link>
          </item>
        </channel>
      </rss>
    XML

    result = FeedNormalizer.normalize_and_parse(xml_with_relative_urls, "http://example.com/feed.xml")

    assert_equal "http://example.com/", result[:feed].url
    assert_equal "http://example.com/post/1", result[:feed].entries[0].url
    assert_includes result[:applied_filters], "RelativeUrlResolver"
  end
end
```

## 9. 今後の拡張計画

### 9.1 追加予定のフィルタ

#### Pre-parseフィルタ
- `InvalidXmlFixer`: 不正なXML構造の修正
- `CharacterEncodingFixer`: 文字エンコーディング問題の修正

#### Post-parseフィルタ
- `EmptyFieldFiller`: 空フィールドへのデフォルト値設定
- `DateNormalizer`: 日付フォーマットの正規化

### 9.2 UI改善案
- フィルタ詳細の表示切り替え機能
- フィード提供者向けの詳細診断ページ
- 統計情報の表示

## 10. 効果と成果

### 10.1 実現された改善
- ✅ Atom名前空間の問題を自動修正
- ✅ 相対URLを絶対URLに自動変換
- ✅ フィルタ適用の透明性確保
- ✅ 完全自動化（手動設定不要）

### 10.2 技術的特徴
- **2層構造**: Pre-parse（XML）とPost-parse（オブジェクト）で段階的処理
- **透明性**: 適用されたフィルタと修正内容を記録
- **拡張性**: 新しいフィルタを簡単に追加可能
- **非破壊的**: 元のデータを保持しつつ修正

## 11. まとめ

このフィード正規化フィルタシステムは、「不完全なフィードを拒否する」のではなく「修正可能な問題は自動的に解決する」という寛容な設計思想を実現している。フィルタは完全に自動で適用され、その過程を透明化することで、フィード提供者とフィード利用者の双方にメリットをもたらす。

現在は基本的な2つのフィルタのみが実装されているが、アーキテクチャは拡張可能な設計となっており、今後さらに多くの問題パターンに対応できる。
